---
title: "Data versioning"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data versioning}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
example_dir <- file.path(tempdir(),"resrepo_example")
unlink(example_dir,recursive = TRUE)
dir.create(example_dir, showWarnings = FALSE)
example_repo <- git2r::init(example_dir, branch = "main")
git2r::config(example_repo, user.name = "Test", user.email = "test@example.org")
vignette_dir<-getwd()
knitr::opts_knit$set(root.dir = example_dir)
# setwd(example_dir)
example_dir
```

In many scientific projects, data are simply too large to be stored in a git repository. 
However, you still want to keep track of the data you used for my analysis, and often you will
be using different code branches to explore alternative approaches (e.g. different data filtering).
`res_repo` allows you to create versions of the data directories used in your projects, 
allowing you to easily switch between different versions of the data.

# Setting up data versioning

Let us start by recreating the example repository. This is the same repository
we created in vignette basic_workflow; if you still have that repository, you don't need to run the code below:

```{r, results='hide'}
library(resrepo)
init_resrepo()
file.copy(from = system.file("vignette_example/tux_measurements.csv", package="resrepo"),
          to = path_resrepo("/data/raw/original/tux_measurements.csv"),
          overwrite = TRUE)
file.copy(from = system.file("vignette_example/s01_download_penguins.Rmd", package="resrepo"),
          to = path_resrepo("/code/s01_download_penguins.Rmd"),
          overwrite = TRUE)
knit_to_results(path_resrepo("/code/s01_download_penguins.Rmd"))
file.copy(from = system.file("vignette_example/s02_merge_clean.Rmd", package="resrepo"),
          to = path_resrepo("/code/s02_merge_clean.Rmd"),
          overwrite = TRUE)
knit_to_results(path_resrepo("/code/s02_merge_clean.Rmd"))
file.copy(from = system.file("vignette_example/s03_pca.Rmd", package="resrepo"),
          to = path_resrepo("/code/s03_pca.Rmd"),
          overwrite = TRUE)
knit_to_results(path_resrepo("/code/s03_pca.Rmd"))
git2r::add(path=".")
git2r::commit(message="Save plot", all=TRUE)

```
Let us check that we do have indeed a full repository:
```{r echo=FALSE}
fs::dir_tree()
```

If we want to start versioning the data, we can use the function `version_setup`.

```{r}
version_setup(quiet = TRUE)

```

Let us check what happened:
```{r echo=FALSE}
fs::dir_tree()
```

We can see that both `data/raw` and `data/intermediate` have been moved into `versions`, under the `initial` version,
and that they have been replaced by symlinks. We can use these links as if they were directories, and check that they point correctly
to the directories in `versions`.

```{r}
dir(path_resrepo("/data/raw"))
```

However, note that the data are now NOT being tracked by git, as `versions` is in .gitignore. So, you want to make sure that you have a reliable way to back up your data (we provide a solution in the vignette on `Data mirroring outside a git repository`).

# Adding a new version

We might now want to revise the filtering of data that we are doing.This will
affect some intermediate data and results. Whilst results are tracked in the git
repository, data are not. However, we might want to
compare the alternative filtering approaches. We can use the `version_add()` 
function to create a new version of the data, which we can modify and compare 
to the `initial` version we created earlier. It will also create a new branch in the git repository (with the same name):

```{r}
version_add(new_version = "new_filtering",
            description = "Filtering out some data")
```

Now `data/raw` and `data/intermediate` are symlinks to the `new_filtering` 
version of the data, which is found under `versions/new_filtering`. Each version will be under a new branch of the repository.

```{r echo=FALSE}
fs::dir_tree()
```

Imagine that we have just been told that the first 10 measurements of the penguins
might be considered unreliable, as the scales were showing a low battery warning.
We now will edit the code that merges and cleans the data, and modify it to 
remove the first 10 penguins from the dataset. We us a pre-prepared script for this,
which we copy to the `code` directory:

```{r}
file.copy(from = system.file("vignette_example/new_filtering/s02_merge_clean.Rmd", package="resrepo"),
          to = path_resrepo("code/s02_merge_clean.Rmd"),
          overwrite = TRUE)
```

We can now remove the old version of the intermediate data created by that script:
```{r}
unlink(path_resrepo("data/intermediate/s02_merge_clean"), recursive = TRUE)
```

Note that the version of that directory in the `versions/initial` version of data is still
there, as we have not removed it from the `versions/new_filtering` directory.

```{r echo=FALSE}
fs::dir_tree()
```

If we now knit the new version of the code, where we remove the first 10 penguins, 
the data are written to the `versions/new_filtering/intermediate` directory.

```{r}
knit_to_results(path_resrepo("/code/s02_merge_clean.Rmd"))
```
We can now compare the datasets of our two versions, and we can see that our current version of
the data, which is found in `new_filtering` version, has 10 fewer penguins than the `initial`
version.

```{r}
penguins_new_filtering <- read.csv(path_resrepo("data/intermediate/s02_merge_clean/penguins_na_omit.csv"))

penguins_initial <- read.csv(path_resrepo("/versions/initial/intermediate/s02_merge_clean/penguins_na_omit.csv"))

nrow(penguins_initial)
nrow(penguins_new_filtering)
```
# Merging back into main

If we are happy with the new version, we can merge it back into the main branch. This will mean that our branch `main` will now use the new version of the data (with the 10 less penguins). Before we merge, we need to commit the changes to the branch `new_filtering`.

TODO Make a gif on how to do this
```{r, eval=T, echo=FALSE}
# commit changes
git2r::commit(message="Filter out 10 penguins", all=TRUE)

```

Now we can merge the branch `new_filtering` into the branch `main`, and check
out `main`.

TODO Make a gif on how to do this
```{r, eval=T, echo=FALSE}
# merge in branch
system2("git", args = c("merge new_filtering"))

# checkout main
system2("git", args = c("checkout main"))

# we are still in main
git2r::is_head(git2r::branches()$main)

```

# Switching between versions

We can also stay in the same branch, but switch between the data versions. This can be useful if we want to compare the results of different versions of the data. We can use the `version_switch` function.
```{r}
version_switch("initial")
```

Check that we are indeed writing to the `initial` version:
```{r}
write.csv("blah", path_resrepo("/data/raw/original/my_new_file2.csv"))
```


```{r echo=FALSE}
fs::dir_tree()
```

# Outsource the data 

Demonstrate how to use the function `version_setup` with the argument `resources_path` 
to outsource the data. 


## TO DO 
- add function or (use function that checks r names) to check that 
  versions do not special characters or spaces 
- find ways to break data versioning (cases when you close the repository 
  but don't have the stuff in the rigth path)
- it would be nice to version just some part of the data (copy data_raw during 
  `version_setup` by default and then version with `version_add`)




```{r}

```
