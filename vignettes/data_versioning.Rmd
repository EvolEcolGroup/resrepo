---
title: "Data versioning"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data versioning}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
example_dir <- file.path(tempdir(),"resrepo_example")
unlink(example_dir,recursive = TRUE)
dir.create(example_dir, showWarnings = FALSE)
example_repo <- git2r::init(example_dir, branch = "main")
git2r::config(example_repo, user.name = "Test", user.email = "test@example.org")
vignette_dir<-getwd()
knitr::opts_knit$set(root.dir = example_dir)
# setwd(example_dir)
example_dir
```

In many scientific projects, data are simply too large to be stored in a git repository. 
However, you still want to keep track of the data you used for my analysis, and often you will
be using different code branches to explore alternative approaches (e.g. different data filtering).
`res_repo` allows you to create versions of the data directories used in your projects, 
allowing you to easily switch between different versions of the data.

# Setting up data versioning

Let us start by recreating the example repository. This is the same repository
we created in vignette basic_workflow; if you still have that repository, you don't need to run the code below:

```{r}
library(resrepo)
init_resrepo()
file.copy(from = system.file("vignette_example/tux_measurements.csv", package="resrepo"),
          to = path_resrepo("/data/raw/original/tux_measurements.csv"),
          overwrite = TRUE)
file.copy(from = system.file("vignette_example/s01_download_penguins.Rmd", package="resrepo"),
          to = path_resrepo("/code/s01_download_penguins.Rmd"),
          overwrite = TRUE)
knit_to_results(path_resrepo("/code/s01_download_penguins.Rmd"))
file.copy(from = system.file("vignette_example/s02_merge_clean.Rmd", package="resrepo"),
          to = path_resrepo("/code/s02_merge_clean.Rmd"),
          overwrite = TRUE)
knit_to_results(path_resrepo("/code/s02_merge_clean.Rmd"))
file.copy(from = system.file("vignette_example/s03_pca.Rmd", package="resrepo"),
          to = path_resrepo("/code/s03_pca.Rmd"),
          overwrite = TRUE)
knit_to_results(path_resrepo("/code/s03_pca.Rmd"))
git2r::add(path=".")
git2r::commit(message="Save plot", all=TRUE)

```
Let us check that we do have indeed a full repository:
```{r echo=FALSE}
fs::dir_tree()
```

If we want to start versioning the data, we can use the function `version_setup`.

```{r}
version_setup(quiet = TRUE)

```

Let us check what happened:
```{r echo=FALSE}
fs::dir_tree()
```

We can see that both `data/raw` and `data/intermediate` have been moved into `version_resources`, under the `initial` version,
and that they have been replaced by symlinks. If we use these links as if they were directories, they point correctly
to the directories in `version_resources`.

```{r}
dir(path_resrepo("/data/raw"))
```

However, note that the data are now NOT being tracked by git, as `version_resources` is in .gitignore. So,
you want to make sure that you have a reliable way to back up your data (we provide a solution
in the vignette on `Data mirroring outside a git repository`).

# Adding a new version

We might now want to revise the filtering of data that we are doing. As this will
affect some intermediate and results, we want to version the data before we start,
so that we can compare the two versions.
```{r}
version_add(new_version = "new_filtering",
            description = "Filtering out some data")
```
```{r echo=FALSE}
fs::dir_tree()
```
We now will edit the code that filters the data, that removes the first 10 penguins from the dataset.

```{r}

file.copy(from = system.file("vignette_example/new_filtering/s02_merge_clean.Rmd", package="resrepo"),
          to = path_resrepo("code/s02_merge_clean.Rmd"),
          overwrite = TRUE)
```

Now, the copy of the code is in the new branch `new_filtering`. We can now check that we are indeed in a different branch.

```{r}
git2r::is_head(git2r::branches()$new_filtering)

```

If we now knit the new version of the code, where we remove the first 10 penguins, we will see that the data are written to the `version_resources/new_filtering/intermediate` directory.

```{r}
knit_to_results(path_resrepo("/code/s02_merge_clean.Rmd"))
```
We can now compare the datasets of our two versions, and we can see that our `new_filtering` version has 10 fewer penguins.

```{r}
penguins_initial <- read.csv(path_resrepo("/version_resources/initial/intermediate/s02_merge_clean/penguins_na_omit.csv"))

penguins_new_filtering <- read.csv(path_resrepo("/version_resources/new_filtering/intermediate/s02_merge_clean/penguins_na_omit.csv"))

nrow(penguins_initial)
nrow(penguins_new_filtering)

```
# Merging back into main

If we are happy with the new version, we can merge it back into the main branch. This will mean that our branch `main` will now use the new version of the data (with the 10 less penguins). Before we merge, we need to commit the changes to the branch `new_filtering`.

TODO Make a gif on how to do this, but dont show in vignette
```{r, eval=T, echo=FALSE}
# commit changes
git2r::commit(message="Filter out 10 penguins", all=TRUE)

```


```{r}
# merge in branch
system2("git", args = c("merge new_filtering"))

# checkout main
system2("git", args = c("checkout main"))

# we are still in main
git2r::is_head(git2r::branches()$main)

```

# Switching between versions

We can also stay in the same branch, but switch between the data versions. This can be useful if we want to compare the results of different versions of the data. We can use the `version_switch` function.
```{r}
version_switch("initial")
```

Check that we are indeed writing to the `initial` version:
```{r}
write.csv("blah", path_resrepo("/data/raw/original/my_new_file2.csv"))
```


```{r echo=FALSE}
fs::dir_tree()
```
```{r}

```