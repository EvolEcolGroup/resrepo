---
title: "Using symbolic links"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using symbolic links}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
# define base directory
base_dir <- file.path(tempdir(),"mydrive")
#clean it up if it already existed and had old content
unlink (base_dir, recursive = TRUE)
# define the directories
onedrive_dir <- file.path(base_dir ,"onedrive/gitdata")
git_dir <- file.path(base_dir ,"git/project1")
# create them
dir.create(onedrive_dir, recursive = TRUE)
dir.create(git_dir, recursive = TRUE)
vignette_dir<-getwd()
# initialise the git repository
example_repo <- git2r::init(path=git_dir)
git2r::config(example_repo, user.name = "Test", user.email = "test@example.org")
# set the working directory for markdown here
knitr::opts_knit$set(root.dir = git_dir)
```


```{r echo=FALSE, results="hide"}
# now that that the working directory is in the git repository
# we set up the resrepo for the project
resrepo::init_resrepo()  # make all the resrepo folders
git2r::add(path=".")  # add all the new files to git
git2r::commit(message="initialise resrepo template", all=TRUE)  # commit them
```

# Using symbolic links in resrepo

This vignette shows how to use symbolic links within *resrepo*. `git` is designed to manage software code, but it is not suited to track large data files. 

By default, the git repository does not track data files (as they are often too large for `git`), and each sub-directory should have a remote source that will allow others using the repository to get the data. There should be one source for each first level subdirectory (e.g. `/data/raw/defaults` or `/data/intermediates/rnaseq`); you are then free to further structure (or not) your data within multiple, higher level sub-directories within each first level sub-dir. If your datasets are small and stored as text files, you might decide to track them within your git repository. In that case, set the "source"" and "url"" as "git" in the data_sources.csv table for that sub-directory, and edit appropriately .gitignore.

When integrating `git` with cloud systems such as *OneDrive*, *Google Drive* issues can arise (**EXAMPLE LINK 1 EXAMPLE LINK 2**), so we encourage to place the directory from your computer linked to the github project in a location that is not backed up, and then store the data separately in a backed-up directory.

# What are symbolic links

A **symbolic link** (also known as symlink or soft link) is a used to point to a file or directory (called the "target") by specifying the path in the file itself (=*target*). The system sees the symlink as a file or (especially in this case) a directory in which data can be written, but when it tries to access the location it is directly redirected to the target path. This allows to keep functional absolute paths within the git project while at the same time writing data into a mirrored directory outside of it.

# Project structure

We will be working in the temporary directory, where we have set up an example
file system. In the vignette, we will use the variable `base_dir` as the root
of our file system, but you will have to us the appropriate path on your own
system.

In this vignette, we have assume the following drive structure:

```{r echo=FALSE}
fs::dir_tree(path=base_dir)
```

with `./git` being the directory that contains your git repositories (which are
likely connected to their GitHub or Gitlab remotes), and `./onedrive` being the
directory mirrored on the cloud. Our project repository (initialised with
`init_resrepo()` as shown in the main vignette) is found in
`./git/project1`. In our mirrored
directory `./onedrive`, we have created a `gitdata` directory, where we plan to store our project data in a sub-directory
with the same name.

The code in the rest of this vignette assumes that you have set the root of the git repository 
`project1` as your working directory:
```{r}
getwd()
```

We don't want to use the `default` directory in `/data/raw`, so we remove it:
```{r}
library(resrepo)
data_source_delete("/data/raw/default")
```

We start by initialising a mirror directory in `./onedrive/gitdata/`. The full path
to that directory is stored in the variable `onedrive_dir`:
```{r}
onedrive_dir <- file.path(base_dir,"onedrive/gitdata")
init_mirror(onedrive_dir)
```

We can see that we have created a `project1` directory in `./onedrive/gitdata/`.
That directory contains all the data subdirectories found in our git project,
but not the other subdirectories (i.e. code, results, writing):

```{r echo=FALSE}
fs::dir_tree(path=base_dir)
```
We now want to add a data subdirectory that will actually hold our data (i.e. 
under /data/raw). We will call it `data_input` (so, `/data/raw/data_input`).
To allow mirroring, we will actually create the directory not under
`git/project1/data/raw/`, but rather in `mydrive/git/project1/data/raw`, and
instead put a symlink pointing to it in `git/project1/data/raw/`.

So, first, create the directory in onedrive:

```{r}
# create the new directory
dir.create(file.path(onedrive_dir,"project1/data/raw/data_input"), recursive = TRUE)
```
```{r echo=FALSE}
fs::dir_tree(base_dir)
```

And now we create the symbolic link:
```{r}
data_dir_link(link_dir = "/data/raw/data_input",
              target_dir = file.path(base_dir,
                                     "onedrive/gitdata/project1/data/raw/data_input"))
```

```{r echo=FALSE}
fs::dir_tree(path=base_dir)
```

We can see that we now have what looks like a directory called `data_input` in
the git repository. Indeed, R thinks the directory exists:
```{r}
dir.exists(path_resrepo("/data/raw/data_input"))
```
And we fail our check on data sources as we have not added it yet:
```{r error=TRUE}
data_source_check()
```
After adding it, all is well:
```{r}
data_source_add(dir = "/data/raw/data_input",
                source = "onedrive",
                url = "https://my_one_drive/link_to_data_input")
data_source_check()
```

In reality, this is a link to the directory with the same
name under one drive. If we write a file within our git repository, we can see
that the file is actually stored on onedrive:

```{r}
write.csv("some content to put in the file",
          path_resrepo("/data/raw/data_input/new_data_file.csv"))
```

```{r echo=FALSE}
fs::dir_tree(path=base_dir)
```
However, we can retrieve the file by targeting the directory within our `git`
repository:
```{r}
read.csv(path_resrepo("/data/raw/data_input/new_data_file.csv"))
```


